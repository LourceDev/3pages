use argon2::{
    Argon2, PasswordVerifier,
    password_hash::{PasswordHasher, SaltString},
};
use jsonwebtoken::{EncodingKey, Header, encode};
use rand_core::OsRng;
use serde::{Deserialize, Serialize};
use std::env;
use time::OffsetDateTime;

pub fn hash_password(password: &str) -> String {
    let params = argon2::ParamsBuilder::new()
        .m_cost(47104)
        .t_cost(2)
        .p_cost(1)
        .build()
        .unwrap();
    let argon2 = Argon2::new(argon2::Algorithm::Argon2id, argon2::Version::V0x13, params);
    let salt = SaltString::generate(&mut OsRng);

    argon2
        .hash_password(password.as_bytes(), &salt)
        .unwrap()
        .to_string()
}

pub fn verify_password(password: &str, password_hash: &str) -> bool {
    let parsed_hash = argon2::PasswordHash::new(password_hash).unwrap();
    Argon2::default()
        .verify_password(password.as_bytes(), &parsed_hash)
        .is_ok()
}

pub fn create_jwt(user_id: i64) -> String {
    #[derive(Debug, Serialize, Deserialize)]
    struct Claims {
        // match js server behavior
        #[serde(rename = "userId")]
        user_id: i64,
        iat: usize, // Optional. Issued at (as UTC timestamp)
        exp: usize, // Required (validate_exp defaults to true in validation). Expiration time (as UTC timestamp)
    }

    let claims = Claims {
        user_id,
        iat: OffsetDateTime::now_utc().unix_timestamp() as usize,
        exp: (OffsetDateTime::now_utc() + time::Duration::days(7)).unix_timestamp() as usize,
    };

    encode(
        &Header::default(),
        &claims,
        &EncodingKey::from_secret(env::var("JWT_SECRET").expect("JWT_SECRET not set").as_ref()),
    )
    .unwrap()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    /// to ensure that we can verify existing password hashes generated by js
    /// server.
    fn verify_existing_hash() {
        let password = "jack@example.com";
        let old_hash = "$argon2id$v=19$m=47104,t=2,p=1$Wej+XgzGzI6kDYK+8F3DPA$9aeemDzDmYWBr3aUBiUl4m3WvcFUOB1f1+aSfnUM5X4";
        assert!(verify_password(password, old_hash));
    }

    #[test]
    /// to ensure that we can verify newly created password hashes
    fn verify_new_hash() {
        let password = "jack@example.com";
        let new_hash = hash_password(password);
        assert!(verify_password(password, &new_hash));
    }
}
