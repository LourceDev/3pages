use crate::env::Env;
use argon2::{
    Argon2, PasswordVerifier,
    password_hash::{PasswordHasher, SaltString},
};
use jsonwebtoken::{DecodingKey, EncodingKey, Header, TokenData, Validation, decode, encode};
use rand_core::OsRng;
use serde::{Deserialize, Serialize};
use time::OffsetDateTime;

pub fn hash_password(password: &str) -> Result<String, argon2::password_hash::Error> {
    // ref: https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#argon2id
    let params = argon2::ParamsBuilder::new()
        .m_cost(47104)
        .t_cost(1)
        .p_cost(1)
        .build()
        .expect("Expected valid argon2 parameters");
    let argon2 = Argon2::new(argon2::Algorithm::Argon2id, argon2::Version::V0x13, params);
    let salt = SaltString::generate(&mut OsRng);

    argon2
        .hash_password(password.as_bytes(), &salt)
        .map(|ph| ph.to_string())
}

pub fn verify_password(password: &str, password_hash: &str) -> bool {
    argon2::PasswordHash::new(password_hash).is_ok_and(|parsed| {
        Argon2::default()
            .verify_password(password.as_bytes(), &parsed)
            .is_ok()
    })
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Claims {
    // match js server behavior
    #[serde(rename = "userId")]
    pub user_id: i64,
    iat: usize, // Optional. Issued at (as UTC timestamp)
    exp: usize, // Required (validate_exp defaults to true in validation). Expiration time (as UTC timestamp)
}

pub fn create_jwt(user_id: i64) -> Result<String, jsonwebtoken::errors::Error> {
    let claims = Claims {
        user_id,
        iat: OffsetDateTime::now_utc().unix_timestamp() as usize,
        exp: (OffsetDateTime::now_utc() + time::Duration::days(7)).unix_timestamp() as usize,
    };

    encode(
        &Header::default(),
        &claims,
        &EncodingKey::from_secret(Env::get().jwt_secret.as_ref()),
    )
}

pub fn decode_jwt(token: &str) -> Option<TokenData<Claims>> {
    decode::<Claims>(
        token,
        &DecodingKey::from_secret(Env::get().jwt_secret.as_ref()),
        &Validation::default(),
    )
    .ok()
}

pub mod trimmed_string {
    use serde::{self, Deserialize, Deserializer};

    pub fn deserialize<'de, D>(deserializer: D) -> Result<String, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        Ok(s.trim().to_string())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    /// to ensure that we can verify existing password hashes generated by js
    /// server.
    fn verify_existing_hash() {
        let password = "jack@example.com";
        let old_hash = "$argon2id$v=19$m=47104,t=2,p=1$Wej+XgzGzI6kDYK+8F3DPA$9aeemDzDmYWBr3aUBiUl4m3WvcFUOB1f1+aSfnUM5X4";
        assert!(verify_password(password, old_hash));
    }

    #[test]
    /// to ensure that we can verify newly created password hashes
    fn verify_new_hash() {
        let password = "jack@example.com";
        let new_hash = hash_password(password).expect("Failed to hash password");
        assert!(verify_password(password, &new_hash));
    }
}
