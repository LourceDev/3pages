use argon2::{
    Argon2, PasswordVerifier,
    password_hash::{PasswordHasher, SaltString},
};
use jsonwebtoken::{DecodingKey, EncodingKey, Header, TokenData, Validation, decode, encode};
use rand_core::OsRng;
use serde::{Deserialize, Deserializer, Serialize};
use time::{OffsetDateTime, macros::format_description};

use crate::env::Env;

pub fn hash_password(password: &str) -> Result<String, argon2::password_hash::Error> {
    let params = argon2::ParamsBuilder::new()
        .m_cost(47104)
        .t_cost(2)
        .p_cost(1)
        .build()
        .expect("Expected valid argon2 parameters");
    let argon2 = Argon2::new(argon2::Algorithm::Argon2id, argon2::Version::V0x13, params);
    let salt = SaltString::generate(&mut OsRng);

    argon2
        .hash_password(password.as_bytes(), &salt)
        .map(|ph| ph.to_string())
}

pub fn verify_password(password: &str, password_hash: &str) -> bool {
    argon2::PasswordHash::new(password_hash).is_ok_and(|parsed| {
        Argon2::default()
            .verify_password(password.as_bytes(), &parsed)
            .is_ok()
    })
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Claims {
    // match js server behavior
    #[serde(rename = "userId")]
    pub user_id: i64,
    iat: usize, // Optional. Issued at (as UTC timestamp)
    exp: usize, // Required (validate_exp defaults to true in validation). Expiration time (as UTC timestamp)
}

pub fn create_jwt(user_id: i64) -> Result<String, jsonwebtoken::errors::Error> {
    let claims = Claims {
        user_id,
        iat: OffsetDateTime::now_utc().unix_timestamp() as usize,
        exp: (OffsetDateTime::now_utc() + time::Duration::days(7)).unix_timestamp() as usize,
    };

    encode(
        &Header::default(),
        &claims,
        &EncodingKey::from_secret(Env::get().jwt_secret.as_ref()),
    )
}

pub fn decode_jwt(token: &str) -> Option<TokenData<Claims>> {
    decode::<Claims>(
        token,
        &DecodingKey::from_secret(Env::get().jwt_secret.as_ref()),
        &Validation::default(),
    )
    .ok()
}

// ref: https://serde.rs/field-attrs.html#deserialize_with
pub fn deserialize_date_from_string<'de, D>(deserializer: D) -> Result<OffsetDateTime, D::Error>
where
    D: Deserializer<'de>,
{
    let s = String::deserialize(deserializer)?;
    get_date_from_string(&s).map_err(serde::de::Error::custom)
}

pub fn get_date_from_string(date: &str) -> Result<OffsetDateTime, String> {
    let format = format_description!("[year]-[month]-[day]");
    time::Date::parse(date, &format)
        .map(|d| d.with_time(time::Time::MIDNIGHT).assume_utc())
        .map_err(|_| format!("Failed to parse date: {}", date))
}

pub fn offset_date_time_to_yyyy_mm_dd(date: OffsetDateTime) -> Result<String, time::error::Format> {
    date.format(format_description!("[year]-[month]-[day]"))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    /// to ensure that we can verify existing password hashes generated by js
    /// server.
    fn verify_existing_hash() {
        let password = "jack@example.com";
        let old_hash = "$argon2id$v=19$m=47104,t=2,p=1$Wej+XgzGzI6kDYK+8F3DPA$9aeemDzDmYWBr3aUBiUl4m3WvcFUOB1f1+aSfnUM5X4";
        assert!(verify_password(password, old_hash));
    }

    #[test]
    /// to ensure that we can verify newly created password hashes
    fn verify_new_hash() {
        let password = "jack@example.com";
        let new_hash = hash_password(password).expect("Failed to hash password");
        assert!(verify_password(password, &new_hash));
    }
}
